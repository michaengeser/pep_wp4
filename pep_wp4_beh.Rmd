---
title: "PEP_wp4_beh"
output: html_document
date: "2023-12-15"
---

# housekeeping

```{r huosekeeping}
# clear workspace
rm(list = ls())

wd = 'C:/Users/JLU-SU/OneDrive - Justus-Liebig-Universität Gießen/Dokumente/GitHub/pep_wp4_analysis'
setwd(wd)
dir()

# get package manager package
if (!('pacman' %in% installed.packages()))
{install.packages("pacman")}
library(pacman)

# install all needed packages 

pacman::p_load('dplyr', 'ggdist', 'ggeffects', 'ggpubr', 'lme4', 'emmeans', 'rstatix', 'car', 'rsq', 'sjPlot', 'brms')

```


# loading files

```{r loading}
# details of subjects  
subNums = c(101) # 105, 106, 108, 109, 110, 113, 114, 115, 118, 122) # 101 excluded
n = length(subNums)
sessions = c(1,2)
tasks = c('categorization', 'typicality', 'familiarity', 'aesthetic', 'usability', 'complexity')
categories = c('bathroom', 'kitchen')

# prepare loading
count = 0
sub_ids = NaN
table_size = 1:18

# loading the files 

for (subNum in subNums ){
    for (task in tasks ){
      for (category in categories ){    
        count = count + 1

        # make session number
        if (task == 'categorization'){ ses = 1 }
        else { ses = 2 }
        
        sub_folder = paste0('sub-', subNum)
        ses_folder = paste0('ses-', ses)
        
        # make file name
        if (task == 'categorization'){
          file_name = paste0(sub_folder, '_', ses_folder, '_run-all_task-', task,'_events.csv')
        } else {
          file_name = paste0(sub_folder, '_', ses_folder, '_run-all_task-', task , '_' ,category, '_events.csv')
        }
        
        # make path
        setwd("..")
        parent_dir = getwd()
        setwd(wd)
        
        if (task == 'categorization'){
        file = file.path(parent_dir, 'pep_wp4', 'data', sub_folder, ses_folder, task, file_name)
        } else {
        file = file.path(parent_dir, 'pep_wp4', 'data', sub_folder, ses_folder, task, category, file_name)
        }
          
          
        # load file
        event_table = read.csv(file)
        
        # concatenate the tables
        if ( exists('all_event_table')){
          all_event_table = rbind(all_event_table, event_table)
        } else {
          all_event_table = event_table
        }
      }}}

```

# apply trial exclusion

```{r trial_exclusion}

# come up with trial removal

```

# transfrom data

``` {r transform_data}

# does data need any other transforamtion

# make task tables
cate_table = all_event_table %>% filter(is_practice == 0 & task == 'categorization')
typ_table = all_event_table %>% filter(is_practice == 0 & task == 'typicality')
fam_table = all_event_table %>% filter(is_practice == 0 & task == 'familiarity')
aes_table = all_event_table %>% filter(is_practice == 0 & task == 'aesthetic')
use_table = all_event_table %>% filter(is_practice == 0 & task == 'usability')
com_table = all_event_table %>% filter(is_practice == 0 & task == 'complexity')

# split by category
cate_table_bath = cate_table %>% filter(category == 'bathroom')
cate_table_kit = cate_table %>% filter(category == 'kitchen')

# image identity table
img_id_table = cate_table %>%  group_by(sub_num, image, category) %>%
  summarise(mean_RT = mean(RT, na.rm = TRUE),
            sd_RT = sd(RT, na.rm = TRUE),
            mean_acc = mean(trial_accuracy, na.rm = TRUE),
            sd_acc = sd(trial_accuracy, na.rm = TRUE))

# sort based on image name 
img_id_table = img_id_table %>% arrange(sub_num, category, image)

# add ratings
# img_id_table = img_id_table %>% mutate(typicality = typ_table %>% arrange(sub_num, category, image) %>% pull(trial_response))
# img_id_table = img_id_table %>% mutate(familiarity = fam_table %>% arrange(sub_num, category, image) %>% pull(trial_response))
# img_id_table = img_id_table %>% mutate(aesthetic = aes_table %>% arrange(sub_num, category, image) %>% pull(trial_response))
# img_id_table = img_id_table %>% mutate(usability = use_table %>% arrange(sub_num, category, image) %>% pull(trial_response))
# img_id_table = img_id_table %>% mutate(complexity = com_table %>% arrange(sub_num, category, image) %>% pull(trial_response))

##### CHECK IS RATING ARE CORRECT #### ALSO CHECK IF RT AND ACC MAKE SENSE (compare with matlab script)


```


# performance

``` {r perfromance}
perf = data.frame(matrix(ncol = 0, nrow = 1))
perf$sub_num = 'NaN'
perf$mean_acc = NaN
perf$mean_RT = NaN
perf$mean_typ = NaN
perf$mean_fam = NaN
perf$mean_aes = NaN
perf$mean_use = NaN
perf$mean_com = NaN
perf = perf[-c(1), ]

for (sub_num in subNums) {
  perf = perf %>% add_row(sub_num = as.character(sub_num),
                          mean_acc = mean(all_event_table %>% filter(sub_num == sub_num & task == 'categorization') %>% pull(trial_accuracy)),
                          mean_RT = mean(all_event_table %>% filter(sub_num == sub_num & task == 'categorization') %>% pull(RT)),
                          mean_typ = mean(all_event_table %>% filter(sub_num == sub_num & task == 'typicality') %>% pull(trial_response)),
                          mean_fam = mean(all_event_table %>% filter(sub_num == sub_num & task == 'familiarity') %>% pull(trial_response)),
                          mean_aes = mean(all_event_table %>% filter(sub_num == sub_num & task == 'aesthetic') %>% pull(trial_response)),
                          mean_use = mean(all_event_table %>% filter(sub_num == sub_num & task == 'usability') %>% pull(trial_response)),
                          mean_com = mean(all_event_table %>% filter(sub_num == sub_num & task == 'complexity') %>% pull(trial_response)))
  }


# add mean and SD
perf = perf %>% add_row(sub_num = 'mean',
                        mean_acc = mean(perf$mean_acc),
                        mean_RT = mean(perf$mean_RT),
                        mean_typ = mean(perf$mean_typ),
                        mean_fam = mean(perf$mean_fam),
                        mean_aes = mean(perf$mean_aes),
                        mean_use = mean(perf$mean_use),
                        mean_com = mean(perf$mean_com))

perf = perf %>% add_row(sub_num = 'sd',
                        mean_acc = sd(perf$mean_acc[1:n]),
                        mean_RT = sd(perf$mean_RT[1:n]),
                        mean_typ = sd(perf$mean_typ[1:n]),
                        mean_fam = sd(perf$mean_fam[1:n]),
                        mean_aes = sd(perf$mean_aes[1:n]),
                        mean_use = sd(perf$mean_use[1:n]),
                        mean_com = sd(perf$mean_com[1:n]))
```

# plotting - categorization performance 

```{R plotting_RT}


### HISTOGRAMS

# subject accuracy
sub_acc_table = cate_table %>%  group_by(sub_num, category) %>%
  summarise(mean_RT = mean(RT, na.rm = TRUE),
            sd_RT = sd(RT, na.rm = TRUE),
            mean_acc = mean(trial_accuracy, na.rm = TRUE),
            sd_acc = sd(trial_accuracy, na.rm = TRUE))

hist_sub_acc = ggplot(sub_acc_table, aes(x=mean_acc, fill=category)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Image accuracy histogram")+
  xlim(c(0.5,1))
hist_sub_acc


# reaction time
hist_RT = ggplot(cate_table, aes(x=RT, fill=category)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("RT histogram")
hist_RT

# accuracy - per image
hist_acc = ggplot(img_id_table, aes(x=mean_acc, fill=category)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Image accuracy histogram")+
  xlim(c(0.5,1))
hist_acc

# RT - per image
hist_img_RT = ggplot(img_id_table, aes(x=mean_RT, fill=category)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Image RT histogram")
hist_img_RT

# RT sd - per image
hist_img_acc = ggplot(img_id_table, aes(x=sd_RT, fill=category)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Image RT SD histogram")
hist_img_acc


```

# main plotting - iT 

```{R main_plotting_IT}

n = length(subNums)

# p 1 by duration, extended time - by task relevance

SOA_SOA_lock_subj_data4 = target_event_table %>% group_by(onset_SOA, SOA_lock, sub_id, task_relevance, duration) %>%
  summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000,
            iT_aud_mean = mean(iRT_aud, na.rm = TRUE),
            iT_vis_mean = mean(iRT_vis, na.rm = TRUE))

# modify duration to show only one duration at the onset 
SOA_SOA_lock_subj_data4= SOA_SOA_lock_subj_data4 %>% mutate(duration = ifelse(SOA_lock == 'onset',0,duration))


SOA_SOA_lock_data4 = SOA_SOA_lock_subj_data4 %>%  group_by(onset_SOA, SOA_lock, task_relevance, duration) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT/sqrt(n),
            mean_iT_aud = mean(iT_aud_mean, na.rm = TRUE),
            sd_iT_aud = sd(iT_aud_mean, na.rm = TRUE),
            sem_iT_aud = sd_iT_aud/sqrt(n),
            mean_iT_vis = mean(iT_vis_mean, na.rm = TRUE),
            sd_iT_vis = sd(iT_vis_mean, na.rm = TRUE),
            sem_iT_vis = sd_iT_vis/sqrt(n))

# define order
SOA_SOA_lock_data4$task_relevance = factor(SOA_SOA_lock_data4$task_relevance , levels=c('target','non-target','irrelevant'))


vis_data4 = target_event_table %>% group_by(onset_SOA,SOA_lock, sub_id, task_relevance, duration) %>%
  summarise(RT_mean_vis = mean(RT_vis, na.rm = TRUE))

# modify duration to show only one duration at the onset 
vis_data4= vis_data4 %>% mutate(duration = ifelse(SOA_lock == 'onset',0,duration))

vis_data4 = vis_data4 %>%  group_by(onset_SOA, SOA_lock, task_relevance, duration) %>%
  summarise(mean_RT_vis = mean(RT_mean_vis, na.rm = TRUE),
            sd_RT_vis = sd(RT_mean_vis, na.rm = TRUE),
            sem_RT_vis = sd_RT_vis / sqrt(n))


# remove NaNs from auditory responses
vis_data4 = vis_data4[!is.na(vis_data4$mean_RT_vis), ]

# Define order and relabel levels for the task_relevance variable
SOA_SOA_lock_data4$task_relevance <- factor(SOA_SOA_lock_data4$task_relevance,
                                            levels = c('target', 'non-target', 'irrelevant'),
                                            labels = c('Target', 'Relevant non-target', 'Irrelevant non-target'))
vis_data4$task_relevance <- factor(vis_data4$task_relevance,
                                   levels = c('target'),
                                   labels = c('Target'))


p13 = ggplot(data = SOA_SOA_lock_data4, aes(x = onset_SOA * 1000, y = mean_RT, group = interaction(as.character(duration), SOA_lock), linetype = SOA_lock, color = 'RT aud')) +
  geom_errorbar(aes(ymin = (mean_iT_vis - sem_iT_vis), ymax = (mean_iT_vis + sem_iT_vis), color = 'IT vis'), width = 30, linewidth = 1) +
  geom_line(data = vis_data4, aes(x = onset_SOA * 1000, y = mean_RT_vis * 1000, color = 'RT vis', linetype = SOA_lock),linewidth = 1) +
  geom_errorbar(data = vis_data4, aes(x = onset_SOA * 1000, y = mean_RT_vis * 1000, ymin = (mean_RT_vis - sem_RT_vis) * 1000, ymax = (mean_RT_vis + sem_RT_vis) * 1000, color = 'RT vis'), width = 30, linewidth = 1) +
  geom_point(data = vis_data4, aes(x = onset_SOA * 1000, y = mean_RT_vis * 1000, color = 'RT vis', linetype = SOA_lock), size = 1.5) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  geom_errorbar(aes(ymin = (mean_RT - sem_RT), ymax = (mean_RT + sem_RT)), width = 30, linewidth = 1) +
  geom_line(aes(y = mean_iT_aud, linetype = SOA_lock, color = 'IT aud'), linewidth = 1) +
  geom_point(aes(y = mean_iT_aud, color = 'IT aud'), size = 1.5) +
  geom_errorbar(aes(ymin = (mean_iT_aud - sem_iT_aud), ymax = (mean_iT_aud + sem_iT_aud), color = 'IT aud'), width = 30, linewidth = 1) +
  geom_line(aes(y = mean_iT_vis, linetype = SOA_lock, color = 'IT vis'), linewidth = 1) +
  geom_point(aes(y = mean_iT_vis, color = 'IT vis'), size = 1.5) +
  facet_grid(. ~ task_relevance) +
  labs(title = "Subjective and objective reaction time", tag = "C") +
  ylab("Time [ms]") +
  xlab('SOA to visual onset [ms]') +
  scale_linetype_manual(values = c("solid", "dashed"), name = 'SOA time-locked to', breaks = c('onset', 'offset')) +
  scale_color_manual(values = c('RT aud' = 'black', 'RT vis' = 'darkgrey', 'IT aud' = 'darkgreen', 'IT vis' = '#e600ac'),
                     name = 'Measure',
                     breaks = c('RT aud', 'RT vis', 'IT aud', 'IT vis'),
                     labels = c(expression("RT"[aud]), expression("RT"[vis]~" "), expression("IT"[aud]~" "), expression("IT"[vis]~"  "))) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank(),
        axis.text = element_text(color = "black", size = 15),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20, face="bold"),
        axis.title = element_text(size = 20, face="bold"),
        plot.title = element_text(size = 25, face="bold"),
        plot.tag = element_text(size = 25, face="bold"),
        strip.text = element_text(size = 20))
p13

```

# plotting - iT 

```{R plotting_IT}

# for iRT
hist_5 = ggplot(data=all_event_table)+geom_histogram(aes(x=iRT_aud),col="red")+
  geom_histogram(aes(x=iRT_vis),col="blue")
hist_5

# ITs and objective RT aud split by onset/offset

SOA_SOA_lock_subj_data = all_event_table %>% group_by(SOA, SOA_lock, sub_id) %>%
  summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000,
            iT_aud_mean = mean(iRT_aud, na.rm = TRUE),
            iT_vis_mean = mean(iRT_vis, na.rm = TRUE))

SOA_SOA_lock_data = SOA_SOA_lock_subj_data %>%  group_by(SOA, SOA_lock) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT/sqrt(n),
            mean_iT_aud = mean(iT_aud_mean, na.rm = TRUE),
            sd_iT_aud = sd(iT_aud_mean, na.rm = TRUE),
            sem_iT_aud = sd_iT_aud/sqrt(n),
            mean_iT_vis = mean(iT_vis_mean, na.rm = TRUE),
            sd_iT_vis = sd(iT_vis_mean, na.rm = TRUE),
            sem_iT_vis = sd_iT_vis/sqrt(n))

p1 = ggplot(data=SOA_SOA_lock_data, aes(x=SOA*1000, y=mean_RT, group=SOA_lock, linetype = SOA_lock, color='objective RT')) +
  geom_line()+
  geom_point()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_line(aes(y=mean_iT_aud, group=SOA_lock, linetype = SOA_lock, color='IT aud'))+
  geom_point(aes(y=mean_iT_aud, group=SOA_lock, color='IT aud'))+
  geom_errorbar(aes(ymin = (mean_iT_aud-sem_iT_aud), ymax = (mean_iT_aud+sem_iT_aud), color='IT aud'), width = 20)+
  geom_line(aes(y=mean_iT_vis, group=SOA_lock, linetype = SOA_lock, color='IT vis'))+
  geom_point(aes(y=mean_iT_vis, group=SOA_lock, color='IT vis'))+
  geom_errorbar(aes(ymin = (mean_iT_vis-sem_iT_vis), ymax = (mean_iT_vis+sem_iT_vis), color='IT vis'), width = 20)+
  ylim(c(200,800))+
  ylab("Time [ms]")+
  xlab('SOA [ms]')+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  scale_color_manual(values=c('black', '#e600ac', 'darkgreen'), name = 'Measure', breaks=c('objective RT', 'IT aud', 'IT vis'))+
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 
p1

# p 1 by duration, extended time - by task relevance

SOA_SOA_lock_subj_data2 = target_event_table %>% group_by(SOA, SOA_lock, sub_id, task_relevance) %>%
  summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000,
            iT_aud_mean = mean(iRT_aud, na.rm = TRUE),
            iT_vis_mean = mean(iRT_vis, na.rm = TRUE))

SOA_SOA_lock_data2 = SOA_SOA_lock_subj_data2 %>%  group_by(SOA, SOA_lock, task_relevance) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT/sqrt(n),
            mean_iT_aud = mean(iT_aud_mean, na.rm = TRUE),
            sd_iT_aud = sd(iT_aud_mean, na.rm = TRUE),
            sem_iT_aud = sd_iT_aud/sqrt(n),
            mean_iT_vis = mean(iT_vis_mean, na.rm = TRUE),
            sd_iT_vis = sd(iT_vis_mean, na.rm = TRUE),
            sem_iT_vis = sd_iT_vis/sqrt(n))

# define order
SOA_SOA_lock_data2$task_relevance = factor(SOA_SOA_lock_data2$task_relevance , levels=c('target','non-target','irrelevant'))


p12 = ggplot(data=SOA_SOA_lock_data2, aes(x=SOA*1000, y=mean_RT, group=SOA_lock, linetype = SOA_lock, color='objective RT')) +
  geom_line()+
  geom_point()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_line(aes(y=mean_iT_aud, group=SOA_lock, linetype = SOA_lock, color='IT aud'))+
  geom_point(aes(y=mean_iT_aud, group=SOA_lock, color='IT aud'))+
  geom_errorbar(aes(ymin = (mean_iT_aud-sem_iT_aud), ymax = (mean_iT_aud+sem_iT_aud), color='IT aud'), width = 20)+
  geom_line(aes(y=mean_iT_vis, group=SOA_lock, linetype = SOA_lock, color='IT vis'))+
  geom_point(aes(y=mean_iT_vis, group=SOA_lock, color='IT vis'))+
  geom_errorbar(aes(ymin = (mean_iT_vis-sem_iT_vis), ymax = (mean_iT_vis+sem_iT_vis), color='IT vis'), width = 20)+
  facet_grid(. ~ task_relevance)+
  labs(title = "Subjective and objective reaction time", tag = "B")+
  ylab("Time [ms]")+
  xlab('SOA [ms]')+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  scale_color_manual(values=c('black', '#e600ac', 'darkgreen'), name = 'Measure', breaks=c('objective RT', 'IT aud', 'IT vis'))+
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 
p12


p23 = ggplot(data=SOA_SOA_lock_duration_data3, aes(x=onset_SOA*1000, y=mean_RT*1000, group=interaction(as.character(duration), SOA_lock), color=as.character(duration), linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT)*1000, ymax = (mean_RT+sem_RT)*1000), width = 20)+
  geom_point()+
  ylab("Reaction time [ms]")+
  xlab('SOA to visual onset [ms]')+
  scale_color_manual(values=c('darkviolet','darkorange','darkred'), name = 'Duration [ms]', labels=c('500', '1000', '1500'))+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) +   
  facet_grid(. ~ task_relevance)
p23


# iRT aud by task-relevance

SOA_SOA_lock_task_relevance_subj_i_aud_data = all_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
  summarise(RT_mean = mean(iRT_aud, na.rm = TRUE))

SOA_SOA_lock_task_relevance_i_aud_data = SOA_SOA_lock_task_relevance_subj_i_aud_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT / sqrt(n))


p4 = ggplot(data=SOA_SOA_lock_task_relevance_i_aud_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(150,500))+
  ylab("Introspective auditory reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue'))
p4

# iRT vis by task-relevance

SOA_SOA_lock_task_relevance_subj_i_vis_data = all_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
  summarise(RT_mean = mean(iRT_vis, na.rm = TRUE))

SOA_SOA_lock_task_relevance_i_vis_data = SOA_SOA_lock_task_relevance_subj_i_vis_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT / sqrt(n))


p5 = ggplot(data=SOA_SOA_lock_task_relevance_i_vis_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(0,400))+
  ylab("Introspective visual reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue'))
p5


##  Regression of iRT and RT aud

# full data

# mean of subject data
RT_iRT_data = target_event_table %>% group_by(sub_id) %>%
  summarise(mean_RT = mean(RT_aud*1000, na.rm = TRUE),
            mean_iRT = mean(iRT_aud, na.rm = TRUE))

cor_sub = ggscatter(RT_iRT_data, x = "z_mean_RT", y = "z_mean_iRT", 
                    add = "reg.line", conf.int = TRUE, 
                    cor.coef = TRUE, cor.coef.coord = c(500, 500), cor.method = "pearson")+
  labs(title = "Estimation performance by subject ", tag = "B")+
  xlab("Mean objective auditory reaction time")+
  ylab('Mean subjective auditory reaction time [ms]')+theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank(),
        axis.text = element_text(color = "black", size = 15),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20, face="bold"),
        axis.title = element_text(size = 20, face="bold"),
        plot.title = element_text(size = 25, face="bold"),
        plot.tag = element_text(size = 25, face="bold"))
cor_sub


# iRT vis vs iRT aud
ggscatter(all_event_table, x = "iRT_aud", y = "iRT_vis", color='sub_id',
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")

# auditory RT
cor_aud = ggscatter(target_event_table , x = "z_RT_aud", y = "z_iRT_aud",
                    add = "reg.line", conf.int = TRUE, 
                    cor.coef = TRUE, cor.method = "pearson", cor.coef.size = 6)+
  labs(title = "Estimation performance auditory task", tag = "B")+
  xlab("Objective z-scored reaction time")+
  ylab('Subjective z-scored decision time')+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank(),
        axis.text = element_text(color = "black", size = 15),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20, face="bold"),
        axis.title = element_text(size = 20, face="bold"),
        plot.title = element_text(size = 25, face="bold"),
        plot.tag = element_text(size = 25, face="bold"))
print(cor_aud)

# visual iRT

cor_vis = ggscatter(target_event_table , x = "z_RT_vis", y = "z_iRT_vis",
                    add = "reg.line", conf.int = TRUE, 
                    cor.coef = TRUE,  cor.method = "pearson", cor.coef.size = 6)+
  labs(title = "Estimation performance visual task", tag = "A")+
  xlab("Objective z-scored reaction time")+
  ylab('Subjective z-scored decision time')+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank(),
        axis.text = element_text(color = "black", size = 15),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20, face="bold"),
        axis.title = element_text(size = 20, face="bold"),
        plot.title = element_text(size = 25, face="bold"),
        plot.tag = element_text(size = 25, face="bold"))
print(cor_vis)
```



```{r raincloud_plot}

source("R_rainclouds.R")

# prepare data 
n = length(subNums)

rp_data = all_event_table %>%  group_by(SOA, SOA_lock, sub_id) %>%
  summarise(mean_RT = mean(RT_aud, na.rm = TRUE),
            sd_RT = sd(RT_aud, na.rm = TRUE))

sum_data = rp_data %>%  group_by(SOA, SOA_lock) %>%
  summarise(RT_mean = mean(mean_RT, na.rm = TRUE),
            RT_median = median(mean_RT, na.rm = TRUE),
            RT_sd = sd(mean_RT, na.rm = TRUE),
            RT_sem = RT_sd / sqrt(n))

rp_data$SOAj = jitter(rp_data$SOA, amount = .005)


# define colors
fill_colors = c(rep("pink",5),rep("lightblue",5))
line_colors = c("onset" = "blue", "offset" = "red")

#Rainclouds for repeated measures, additional plotting options 

ggplot(rp_data, aes(x = SOA, y = mean_RT, fill = SOA_lock)) +
  # distribution plot
  geom_flat_violin(aes(fill = interaction(SOA_lock,SOA)),position = position_nudge(x = .02, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+ 
  # connecting individual data points (onset-locked)
  geom_line(data = rp_data %>% filter(SOA_lock =="onset"), aes(x=SOAj+.02, y = mean_RT, group=sub_id), color = 'lightblue',linetype = 1, size=0.1)+
  # connecting individual data points (offset-locked)
  geom_line(data = rp_data %>% filter(SOA_lock =="offset"), aes(x=SOAj+.02, y = mean_RT, group=sub_id), color = 'pink',linetype = 1, linewidth=0.1)+ 
  # individual data points (each subject)
  geom_point(aes(x = as.numeric(SOAj)+.02, y = mean_RT, colour = SOA_lock), size = 0.5, shape = 20) +
  # box plots
  geom_boxplot(aes(x = SOA, y = mean_RT, fill = interaction(SOA_lock,SOA)),outlier.shape = NA, alpha = .5, width = .02, colour = "black")+
  # error bars
  geom_errorbar(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock, ymin = RT_mean-RT_sem, ymax = RT_mean+RT_sem), width = .005)+ 
  # mean line
  geom_line(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock),linetype = 2, size=0.5)+
  # mean points
  geom_point(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock), shape = 18, size=1)+
  # adjust colors 
  scale_fill_manual(values=fill_colors )+scale_color_manual(values = line_colors)

ggsave('../figures/raincloud.png', width = 6, height = 4)


```

# box plot - introspective RT aud

```{r boxplot}

box_plot_data = all_event_table %>%  group_by(sub_id, SOA, SOA_lock, task_relevance, duration) %>% summarise(mean_RT = mean(iRT_aud, na.rm = TRUE), sd_RT = sd(iRT_aud, na.rm = TRUE))

colors = c(rep("red",3),rep("darkred",3),rep("green",3),rep("darkgreen",3),rep("blue",3),rep("darkblue",3),rep("yellow",3), rep("orange",3))

ggplot(box_plot_data, aes(SOA_lock, mean_RT, fill=interaction(duration, task_relevance, SOA))) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() +
  scale_fill_manual(values=colors)

```

# main analysis - model 1 

```{r model1}

## general linear mixed effect model 1 

# fixed effects: SOA (ordinal), SOA-Lock (as c_is_onset,  numeric, centered), Task-relevance (as c_task_relevant, numeric, centered)
# random effects: Subject ID, Duration (ordinal)

# auditory 
aud_model1 = glmer(iRT_aud ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration),
                   family=Gamma(link="log"), data=all_event_table)

summary(aud_model1)
Anova(aud_model1)
plot(fitted(aud_model1),residuals(aud_model1))
qqnorm(residuals(aud_model1))
rsq.glmm(aud_model1)

#### Log instaed of identity function #####

# visual

vis_model1 = glmer(iRT_vis ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration),
                   family=Gamma(link="log"), data=all_event_table)

summary(vis_model1)
Anova(vis_model1)
plot(fitted(vis_model1),residuals(vis_model1))
qqnorm(residuals(vis_model1))
rsq.glmm(vis_model1)
```

# main analysis from experiment 1 

```{r model_exp1}

## general linear mixed effect model from experiment 1

# fixed effects: SOA (ordinal), SOA-Lock (as c_is_onset,  numeric, centered), Task-relevance (as is relevant, numeric, centered)
# random effects: Subject ID, Duration (ordinal)

model_exp1 = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration),
                   family=Gamma(link="identity"), data=all_event_table)

summary(model_exp1)
Anova(model_exp1)
plot(fitted(model_exp1),residuals(model_exp1))
qqnorm(residuals(model_exp1))
rsq.glmm(model_exp1)


# onset PRP analysis


onset_event_table = all_event_table %>% filter(SOA_lock == "onset")

# new model (needs to be adjusted probably)

onset_model = glmer(RT_aud ~ f_SOA*c_task_relevant +
                      (1*f_SOA*c_task_relevant | sub_id) + 
                      (1*f_SOA*c_task_relevant | f_duration), 
                    family = Gamma(link="identity"), data = onset_event_table)

summary(onset_model)
Anova(onset_model)
rsq.glmm(onset_model)


# offset PRP analysis


# do pairwise comparions using tukey correted t-testing 
# post-hoc pairwise comparison

offset_event_table = all_event_table %>% filter(SOA_lock == "offset")

# new model (needs to be adjusted probably)

offset_model = glmer(RT_aud ~ f_SOA*f_duration*c_task_relevant +
                       (1*f_SOA*f_duration*c_task_relevant | sub_id), 
                     family = Gamma(link="identity"), data = offset_event_table)

summary(offset_model)
Anova(offset_model)
rsq.glmm(offset_model)

em1 <- emmeans(offset_model, "f_SOA", by = "f_duration")
contrast(em1, "pairwise", adjust = "bonferroni")


```

# control model - model2

```{r model2}


# with duration, category and pitch as random effects 

model2 = glmer(iRT_aud ~ f_SOA*c_is_onset*c_task_relevant +
                 (1*f_SOA*c_is_onset*c_task_relevant | sub_id) +
                 (1*f_SOA*c_is_onset*c_task_relevant | f_duration) +
                 (1*f_SOA*c_is_onset*c_task_relevant | c_pitch) +
                 (1*f_SOA*c_is_onset*c_task_relevant | category), 
               family=Gamma(link="log"), data=all_event_table)
summary(model2)
Anova(model2)
rsq.glmm(model2)

# compare the two models
anova(aud_model1, model2)

```

# exploratory analayses - plots of pitch, category, orientation and performance

```{r control_plots}

# pitch  

SOA_SOA_lock_pitch_data = all_event_table %>%  group_by(SOA, SOA_lock, c_pitch) %>%
  summarise(mean_iRT = mean(iRT_aud, na.rm = TRUE),
            sd_iRT = mean(iRT_aud, na.rm = TRUE))

pitch_plot = ggplot(data=SOA_SOA_lock_pitch_data, aes(x=SOA*1000, y=mean_iRT, group=interaction(as.character(c_pitch), SOA_lock))) +
  geom_line(aes(color=as.character(c_pitch), linetype = SOA_lock))+
  geom_point()+
  ylim(c(200,500))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue','green'))
pitch_plot


# category 

SOA_SOA_lock_category_data = all_event_table %>%  group_by(SOA, SOA_lock, category) %>%
  summarise(mean_iRT = mean(iRT_aud, na.rm = TRUE),
            sd_iRT = mean(iRT_aud, na.rm = TRUE))

category_plot = ggplot(data=SOA_SOA_lock_category_data, aes(x=SOA*1000, y=mean_iRT, group=interaction(category, SOA_lock))) +
  geom_line(aes(color=category, linetype = SOA_lock))+
  geom_point()+
  ylim(c(200,500))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue','green','orange'))
category_plot


```

# visual iRT specific analyses

```{r iRTvis}


# remove NaNs from auditory responses
task_event_table = all_event_table[!is.na(all_event_table$trial_accuracy_aud), ]

task_mean_iRT_vis = task_event_table %>%  group_by(task_relevance, sub_id) %>%
  summarise(mean_iRT = mean(iRT_vis, na.rm = TRUE),
            sd_iRT = mean(iRT_vis, na.rm = TRUE))

ggbarplot(task_mean_iRT_vis, x = "task_relevance", y = "mean_iRT", 
          add = c("mean_se", "jitter"), fill = "task_relevance")+
  ylab("Mean decision time [ms]")+
  xlab('Task-relevance')+
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
  scale_fill_manual(values = c("red","blue","lightgreen"), name = 'Task Relevance', labels=c('irrelevant', 'task-relevant non-target', 'target'))



task_mean_iRT_vis_df <- data.frame(mean_iRT = task_mean_iRT_vis$mean_iRT, task_relevance = task_mean_iRT_vis$task_relevance) 

# t-test
iRT_aud_pwc <- task_mean_iRT_vis_df %>% 
  pairwise_t_test(
    mean_iRT ~ task_relevance, paired = TRUE,
    p.adjust.method = "bonferroni"
  )
iRT_aud_pwc

```

# how much does PRP effect depend on T1 variabitiy (see Marti et al 2010 and 2012)

```{r corretion IT vis and RT}

target_event_table = target_event_table %>% mutate(f_SOA = factor(SOA, ordered = TRUE, levels = c("0", "0.232", "0.466")))


c1 = ggscatter(target_event_table, x = "z_iRT_vis", y = "RT_aud",
               color = "SOA_lock", palette = "jco",
               add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "pearson") + stat_cor(aes(color = SOA_lock), label.y = c(2.6,2.4,2.2))
c1



# split by SOA and SOA_lock

c2a = ggplot(all_event_table, aes(x = z_iRT_vis, y = RT_aud*1000, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Visual introspective decision time [ms]") +
  ylab("Objective auditory reaction time [ms]") +
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  facet_grid(. ~ SOA_lock)+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)
c2a

c2b = ggplot(all_event_table, aes(x = z_iRT_vis, y = RT_aud*1000, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Visual introspective decision time [ms]") +
  ylab("Objective auditory reaction time [ms]") +
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  facet_grid(duration ~ SOA_lock)+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)
c2b

# split by task-relevance and SOA_lock
c3 = ggplot(target_event_table, aes(x = z_iRT_vis, y = RT_aud*1000, color = task_relevance))+
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = task_relevance))+
  xlab("Visual introspective decision time [ms]")+
  ylab("Objective auditory reaction time [ms]")+
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "Task relevance ", labels = c("Irrelevant", "Non-target", "Target"))+
  facet_grid(. ~ SOA_lock)+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = task_relevance),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)
c3

```

# plot suggested by Stan

```{r}

# percentage of underestimation in RT 

underest_RTaud = mean(all_event_table$iRT_aud)/mean(all_event_table$RT_aud*1000)

# Create the scatter plot with regression lines
c3 = ggplot(all_event_table, aes(x = RT_aud*1000, y = iRT_aud, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Objective auditory reaction time [ms]") +
  ylab("Auditory introspective decision time [ms]") +
  scale_color_manual(values = c("#0073c2", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  facet_grid(task_relevance ~ SOA_lock)+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 1500, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(1400,1300,1200), method = "pearson", show.legend = FALSE)
c3

# binned RTaud vs IRTaud

bins = 1:30

ITaud_bin = data.frame(matrix(ncol = 0, nrow = 1))
ITaud_bin$bin = NaN
ITaud_bin$mean = NaN
ITaud_bin$sd = NaN
ITaud_bin = ITaud_bin[-c(1), ]

for (bin in bins){
  
  bin_table = all_event_table[all_event_table$RT_aud <= bin/10 & all_event_table$RT_aud >= (bin-1)/10, ]
  ITaud_bin = ITaud_bin %>% add_row(bin = bin*100, mean = mean(bin_table$z_iRT_aud),
                                    sd = sd(bin_table$iRT_aud))
  
}


ggplot(ITaud_bin, aes(x= factor(bin), y = mean)) +  
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd)) +
  xlab("Objective auditory reaction time [ms]") +
  ylab("Auditory introspective decision time [ms]")


# median split

all_event_table = all_event_table %>% mutate(iRT_vis_speed = ifelse(z_iRT_vis <= median(z_iRT_vis), "fast","slow"))


ggbarplot(all_event_table, x = "f_SOA", y = "RT_aud", fill = "iRT_vis_speed", facet.by = "SOA_lock", position = position_dodge(0.9),
          add = c("mean_se"))+
  xlab("SOA [ms]") +
  ylab("Auditory reaction time [ms]") +
  scale_fill_manual(values = c("red","blue"), name = 'ITvis Speed', labels=c('fast', 'slow'))


SOA_SOA_lock_iRT1_speed_subj_data = all_event_table %>% group_by(SOA, SOA_lock, sub_id, iRT_vis_speed) %>%
  summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000)

SOA_SOA_lock_iRT1_speed_data = SOA_SOA_lock_iRT1_speed_subj_data %>%  group_by(SOA, SOA_lock, iRT_vis_speed) %>%
  summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
            sd_RT = sd(RT_mean, na.rm = TRUE),
            sem_RT = sd_RT / sqrt(n))


ggplot(data=SOA_SOA_lock_iRT1_speed_data, aes(x=SOA*1000, y=mean_RT, group=interaction(iRT_vis_speed, SOA_lock), color=iRT_vis_speed, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(400,900))+
  ylab("Auditory Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values = c("darkgrey","black"), name = 'ITvis Speed')+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 


ggbarplot(all_event_table, x = "f_SOA", y = "RT_aud", fill = "iRT_vis_speed", facet.by = c("SOA_lock","iRT_vis_speed"), position = position_dodge(0.9),
          add = c("mean_se"))+
  xlab("SOA [ms]") +
  ylab("Auditory reaction time [ms]") +
  scale_fill_manual(values = c("pink","lightblue"), name = 'ITvis Speed', labels=c('fast', 'slow'))


model_T1speed = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed +
                        (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed | sub_id)+
                        (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed | f_duration),
                      family=Gamma(link="identity"), data=all_event_table)

summary(model_T1speed)
Anova(model_T1speed)
plot(fitted(model_T1speed),residuals(model_T1speed))
qqnorm(residuals(model_T1speed))
rsq.glmm(model_T1speed)

# bring IT vis and RT aud into the same unit (secs)
all_event_table = all_event_table %>% mutate(iRT_vis_0.001 = iRT_vis*0.001)

model_T1 = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant*iRT_vis_0.001 +
                   (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_0.001| sub_id)+
                   (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_0.001 | f_duration),
                 family=Gamma(link="identity"), data=all_event_table)

summary(model_T1)
Anova(model_T1)
plot(fitted(model_T1),residuals(model_T1))
qqnorm(residuals(model_T1))
rsq.glmm(model_T1)

```

# bootstrapping RTaud ~ iRTvis  

```{r bootstrapping }

# initiate variables
repetitions = 1000
n = length(subNums)
random_subs = matrix(NA, nrow = repetitions, ncol = n)
r2s = matrix(NA, nrow = repetitions, ncol = 6)
colnames(r2s) = c('on_0', 'off_0', 'on_232', 'off_232', 'on_466', 'off_466')

# start loop
for (rep in 1:repetitions ){
  
  # delete table from previous repetition  
  if (exists('all_sub_table')){rm(all_sub_table)}
  
  # sample random subjects    
  random_subs[rep, ] = sample(subNums, n, replace = TRUE)
  
  # loop through random selected subject and generate new event table
  for (sub in random_subs[rep, ]){
    
    # select table for the subject
    sub_table = all_event_table %>% filter(sub_num == sub)
    
    # concatanate the tables
    if (exists('all_sub_table')){
      all_sub_table = rbind(all_sub_table, sub_table)
    } else {
      all_sub_table = sub_table
    }}
  
  # loop through different SOAs and offset/onset
  count = 0
  for (i in SOA_lvl){
    for (ii in SOA_lock_lvl) {
      count = count + 1
      
      # select subset with corresponding SOAs and offset/onset
      cell_trials_table = all_sub_table %>% filter(SOA == i & SOA_lock == ii) 
      
      # sun model on subset to generate r2
      model2_T1 = glm(RT_aud ~ z_iRT_vis, family=Gamma(link="identity"), data=cell_trials_table)
      r2s[rep, count] = rsq(model2_T1)
      
    }}}

# generate r2 for full data set 
exp_r2s = matrix(NA, nrow = 1, ncol = 6)
colnames(exp_r2s) = c('on_0', 'off_0', 'on_232', 'off_232', 'on_466', 'off_466')

count = 0
for (i in SOA_lvl){
  for (ii in SOA_lock_lvl) {
    count = count + 1
    
    # select subset with corresponding SOAs and offset/onset
    cell_trials_table = all_event_table %>% filter(SOA == i & SOA_lock == ii) 
    
    # sun model on subset
    model2_T1 = glm(RT_aud ~ z_iRT_vis, family=Gamma(link="identity"), data=cell_trials_table)
    exp_r2s[1, count] = rsq(model2_T1)
    
  }}

# Calculate column means and standard deviations
r2s_means = colMeans(r2s)
r2s_sds = apply(r2s, 2, sd)

# Create a data frame
r2s_data = data.frame(column = colnames(r2s), mean = r2s_means, sd = r2s_sds)
r2s_data = r2s_data %>% mutate(se = sd/sqrt(repetitions))
r2s_data = r2s_data %>% mutate(margin_of_error = -qt((1-0.95)/2, repetitions-1)*se)
r2s_data = r2s_data %>% mutate(SOA_lock = rep(c('onset', 'offset'),3))
r2s_data = r2s_data %>% mutate(SOA = c(0, 0, 232, 232, 466, 466))
r2s_data$SOA_lock = factor(r2s_data$SOA_lock, levels = c('onset', 'offset'), ordered = TRUE)

# Create the bar plot
b1 = ggplot(r2s_data, aes(x = factor(SOA), y = mean, fill = factor(SOA))) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  geom_errorbar(aes(ymin = mean - margin_of_error, ymax = mean + margin_of_error), width = 0.2, position = position_dodge(0.9)) +
  facet_grid(. ~ SOA_lock)+
  labs(title = "R"^2~"of RTaud ~ ITvis",
       x = "SOA",
       y = "Mean R"^2~"") +
  scale_fill_manual(values = c("pink","lightblue", 'lightgreen'), name = 'SOA [ms]', labels=c('0', '232', '466'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())
b1

# Create the bar plot task relevance
b2 = ggplot(r2s_data, aes(x = factor(SOA), y = mean, fill = factor(SOA))) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  geom_errorbar(aes(ymin = mean - margin_of_error, ymax = mean + margin_of_error), width = 0.2, position = position_dodge(0.9)) +
  facet_grid(. ~ SOA_lock)+
  labs(title = "R"^2~"of RTaud ~ ITvis",
       x = "SOA",
       y = "Mean R"^2~"") +
  scale_fill_manual(values = c("pink","lightblue", 'lightgreen'), name = 'SOA [ms]', labels=c('0', '232', '466'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())

```

# effect size of PRP

```{r effect size}

# RT AUD -----------------------------------------# 

RT_aud_effect_size_table = matrix(ncol = 6, nrow = 5)
rownames(RT_aud_effect_size_table) = c("Mean_SOA0", "Mean_SOA466", "PRP_size", "joined_SD", "Cohensd")
colnames(RT_aud_effect_size_table) = c("target", "non_target_onset", "irrelevant_onset", "offset_short", "offset_intermediate", "offset_long")

# mean of SOA = 0
RT_aud_effect_size_table[1, ] = c(mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(RT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), na.rm = TRUE), 
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(RT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(RT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(RT_aud), na.rm = TRUE))

# mean of SOA = 466
RT_aud_effect_size_table[2, ] = c(mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(RT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(RT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(RT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(RT_aud), na.rm = TRUE))

# PRP size
RT_aud_effect_size_table[3, ] = RT_aud_effect_size_table[1, ] - RT_aud_effect_size_table[2, ] 

# joined SD
RT_aud_effect_size_table[4, ] = c(sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(RT_aud),target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(RT_aud))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(RT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(RT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(RT_aud))))

# cohens d 
RT_aud_effect_size_table[5, ] = (RT_aud_effect_size_table[1, ] - RT_aud_effect_size_table[2, ])/RT_aud_effect_size_table[4, ]


# IT AUD -----------------------------------------# 


IT_aud_effect_size_table = matrix(ncol = 6, nrow = 5)
rownames(IT_aud_effect_size_table) = c("Mean_SOA0", "Mean_SOA466", "PRP_size", "joined_SD", "Cohensd")
colnames(IT_aud_effect_size_table) = c("target", "non_target_onset", "irrelevant_onset", "offset_short", "offset_intermediate", "offset_long")

# mean of SOA = 0
IT_aud_effect_size_table[1, ] = c(mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_aud), na.rm = TRUE), 
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(iRT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(iRT_aud), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(iRT_aud), na.rm = TRUE))

# mean of SOA = 466
IT_aud_effect_size_table[2, ] = c(mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(iRT_aud), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(iRT_aud), na.rm = TRUE))

# PRP size
IT_aud_effect_size_table[3, ] = IT_aud_effect_size_table[1, ] - IT_aud_effect_size_table[2, ] 

# joined SD
IT_aud_effect_size_table[4, ] = c(sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(iRT_aud),target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(iRT_aud))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_aud))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(iRT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(iRT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(iRT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(iRT_aud))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(iRT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(iRT_aud))))

# cohens d 
IT_aud_effect_size_table[5, ] = (IT_aud_effect_size_table[1, ] - IT_aud_effect_size_table[2, ])/IT_aud_effect_size_table[4, ]

# IT vis -----------------------------------------# 


IT_vis_effect_size_table = matrix(ncol = 6, nrow = 5)
rownames(IT_vis_effect_size_table) = c("Mean_SOA0", "Mean_SOA466", "PRP_size", "joined_SD", "Cohensd")
colnames(IT_vis_effect_size_table) = c("target", "non_target_onset", "irrelevant_onset", "offset_short", "offset_intermediate", "offset_long")

# mean of SOA = 0
IT_vis_effect_size_table[1, ] = c(mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_vis), na.rm = TRUE), 
                                  mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_vis), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(iRT_vis), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(iRT_vis), na.rm = TRUE), 
                                  mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(iRT_vis), na.rm = TRUE))

# mean of SOA = 466
IT_vis_effect_size_table[2, ] = c(mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(iRT_vis), na.rm = TRUE),
                                  mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(iRT_vis), na.rm = TRUE))

# PRP size
IT_vis_effect_size_table[3, ] = IT_vis_effect_size_table[1, ] - IT_vis_effect_size_table[2, ] 

# joined SD
IT_vis_effect_size_table[4, ] = c(sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(iRT_vis),target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(iRT_vis))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_vis), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(iRT_vis))),
                                  sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_vis), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(iRT_vis))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(iRT_vis), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(iRT_vis))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(iRT_vis), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(iRT_vis))),
                                  sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(iRT_vis), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(iRT_vis))))

# cohens d 
IT_vis_effect_size_table[5, ] = (IT_vis_effect_size_table[1, ] - IT_vis_effect_size_table[2, ])/IT_vis_effect_size_table[4, ]

```

# calibration performance

```{r calibration}

# loading the files 

for (subNum in subNums ){
  for (ses in sessions ){
    count = count + 1
    sub_ids[count] = paste0(Lab_ID, subNum)
    
    sub_folder = paste0('sub-', Lab_ID, subNum)
    ses_folder = paste0('ses-', ses)
    file_name = paste0(sub_folder, '_', ses_folder, '_run-1_task-calibration_events.csv')
    
    setwd("..")
    parent_dir = getwd()
    setwd(wd)
    file = file.path(parent_dir, 'Reconstructed_time_experiment', 'data', sub_folder, ses_folder, file_name)
    
    # load file
    cali_table = read.csv(file)
    
    # add subject number and session column 
    cali_table = cali_table %>% mutate(sub_num = subNum)
    cali_table = cali_table %>% mutate(sub_id = paste0(Lab_ID, subNum))
    cali_table = cali_table %>% mutate(ses = ses)
    cali_table = cali_table %>% mutate(estimation_error = -estimation_error)
    cali_table = cali_table %>% mutate(abs_est_error = abs(estimation_error))
    cali_table = cali_table %>% mutate(rel_est_error = abs_est_error/cali_ms)
    
    
    # concatanate the tables
    if ( exists('all_cali_table')){
      all_cali_table = rbind(all_cali_table, cali_table)
    } else {
      all_cali_table = cali_table
    }
  }}

# correlation estimated time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "iT",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")+
  ggtitle("Calibration performance")+
  xlab("Objective tones length [ms]") +
  ylab("Estimated time [ms]") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())


cali = ggscatter(all_cali_table, x = "cali_ms", y = "iT", color='sub_id', 
                 palette = "npg", add = "reg.line",
                 cor.coef = TRUE, cor.method = "pearson") +
  labs(title = "Calibration performance by subject", tag = "A") +
  xlab("Objective tones length [ms]") +
  ylab("Estimated time [ms]") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) +
  guides(color = "none")
cali

# correlation absolute estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "abs_est_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")

# correlation relative estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "rel_est_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")

# correlation relative estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "estimation_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")+
  ggtitle("Calibration error")+
  xlab("Objective tones length [ms]") +
  ylab("Estimation error [ms]") +
  ylim(c(-750,500))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())


# calibration performance split by subject
cali_sub = ggplot(all_cali_table %>% filter(sub_id != 'SX108'), aes(x = cali_ms, y = iT))+
  geom_point() +
  geom_smooth(method = "lm", se = TRUE)+
  facet_wrap(~sub_id, nrow = 3, ncol = 3, scales = "free")+
  xlab("Objective tones length [ms]")+
  ylab("Estimated time [ms]")+
  ylim(c(0,1050))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank(),
        axis.text = element_text(color = "black", size = 15),
        legend.text = element_text(size = 20),axis.title = element_text(size = 20, face="bold"),
        plot.title = element_text(size = 25, face="bold"),
        strip.text = element_text(size = 20))+
  stat_cor(color = 'black', label.y = 1000, method = "pearson", show.legend = FALSE, size = 5)
cali_sub

```


```


# testing duration of experiment

```{r durations}

# duration of core experiment (3 blocks, no practice or calibration task)

# start counter 
ses_counter = 0
core_exp_time = NaN

# loops through subjects and sessions and extract duration 
for (sub_id in sub_ids){
for (ses in sessions){

ses_counter = ses_counter + 1
test_table = all_event_table[all_event_table$sub_id == sub_id & all_event_table$ses == ses, ]

if(dim(test_table)[1] > 0){
core_exp_time[ses_counter] = test_table$trial_end[dim(test_table)[1]] - test_table$TargetScreenOnset[1]
}

}}

print(paste0('Total duration of core experiment was ', round(mean(core_exp_time, na.rm = TRUE)/60), ' min. per session'))

print(paste0('Each miniblock was ', round(mean(core_exp_time, na.rm = TRUE)/60/12), ' min.'))

```
